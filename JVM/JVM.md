# 前沿

官网地址：https://docs.oracle.com/javase/8/

VM参数官方文档：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html

参考文档：[](https://blog.csdn.net/tterminator/article/details/54342666)

# 一.类加载机制



## **1.什么是类加载机制？它的作用是什么？**			

​		类加载机制粗略的描述就是：**将class文件的内容加载到JVM的一个过程**。**具体的描述**：**Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过**程。

​		我们编写的Java源码文件，经过编译器（词法分析/语法分析/语义分析）编辑，生成字节码文件。然后将这个字节码文件交给JVM区解析，这个过程就是类加载。

## 2.类加载的时机



## 3.类加载都有哪些过程？

![](/Users/machen/Documents/data_struct/JVM/imges/WX20200419-154432.png)

### 3.1 装载

在装载阶段，JVM虚拟机需要完成下面三件事情：

1. 通过类的全限定名获取其定义的二进制字节流。需要借助`类装载器`  [classLoader](##类装载器classLoader)完成(就是用来装载Class文件的)。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 
3. 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。

------

==**注意：**==

​		**加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始。**

------



### 3.2 链接

#### 3.2.1 验证

**目的：保证被加载类的正确性**

- 文件格式的验证
- 元数据的验证
- 字节码的验证
- 符号引用的验证



#### 3.2.2 准备

**目的：**为类的`静态变量`分配内存，并将其初始化为默认值。

------

**==备注：==**

​		**1.类中变量所使用的内存是方法区进行分配的（方法区是一个逻辑上的区域，逻辑上属于堆）。**

​		**2.此阶段进行内存分配的只包括类变量，而不包括实例变量。实例变量将会在对象实例化时随着对象一起分配在Java堆中**

​		3.这里所说的初始值“通常情况”下是数据类型的零值。但是对于`静态常量属性`，那在准备阶段变量值就会被初始化为所指定的值，比如下面这个变量：

```java
public static final int value = 123;
```

------



#### 3.2.3  链接-解析

**目的**：把类中的符号引用转换为直接引用

------

==**什么是符号引用，符号引用和直接应用有什么关系？**==

​		**符号引用**：就是一组符号来描述引用的对象。个个虚拟机实现的内存布局可以不同，但是符号引用引用所代表的意思必须相同，因为他是一套规范。

​		**直接引用**：直接的内存地址引用，通过该引用能够确定唯一的一块内存空间。

------

### 3.5 初始化

**目的：对类的静态变量，静态代码块执行初始化操作。**



## 4.类装载器classLoader

​		类加载器虽然只用于实现类的加载动作，

# 二.运行时数据区

## 2.1堆

HotSpot JVM堆的内存分布图：

![](imges/WX20200419-221245.png)



## 2.2 方法区

方法区是`线程共享`的内存区域。







## 2.3 程序计数器

## 2.4  虚拟机栈

## 2.5 运行时常量池

首先**运行时常量池时属于方法区的一部分**（内存分配）。**一个类或者接口被JVM创建加载的同时也会构造该类或接口的运行时常量池**（何时创建 ）。

## 2.6 本地方法区



# 三. GC-垃圾回收

## 3.1 名次解释

- **`MinorGc/YungGc`：**只是**新生代**的垃圾收集操作。
- **`MajorGC/Old GC`：**只是**老年代**的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。
- **`Full GC`：**收集整个Java堆和方法区的垃圾收集。
- **`Mixed GC(混合收集)`**：指**收集整个新生代以及部分老年代**的垃圾收集。目前**只有G1收集器**会有这种行为。

这些回收类型的划分，主要是因为这一设计原则：将**堆划分为不同的区域，垃圾收集器可以每次只回收其中某一个或者某些部分的区域（分代收集的理论）。**



## 3.2 两个重要指标

**`吞吐量`：**处理器用于运行用户代码的时间与处理器总消耗时间的比值。

<img src="imges/WX20200421-151912@2x.png" style="zoom:50%;" />



## 3.3 对象已死？

### 3.3.1 可达性分析



 

------

==**灵魂拷问：**==

**1.谁都可能成为GCRoot？**

​		固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中。

------



## 3.4 清除算法

#### 3.4.1 标记清除算法

算法分为两个阶段**`标记`，`清除`**。

- **首先标记出所有需要回收的对象。**
- **在标记完成后，统一回收掉所有被标记的对象。**



==**该算法的缺点：**==

- **`执行效率不高`**。Java堆中包含大量对象，大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低/

- **`空间碎片化`**。标记/清除后会产生大量不连续的内存碎片，较大内存对象因为空间不够而不得不再次出发一次GC。

<img src="imges/WX20200421-161424@2x.png" style="zoom:50%;" />



#### 3.4.2 标记-复制算法

为了解决上面算法的执行效率问题，提出了“**`半区复制`”**的垃圾收集算法。也就是：**将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉**。



==**新生代中的对象有98%熬不过第一轮收集。因此并不需要按照1∶1的比例来划分新生代的内存空间。**==



==**该算法好处：**==

- **效率高。对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象（这就注定该算法比较实用与年轻代，因为多数的对象都是可回收的）**
- **没有空间碎片问题**。**因为每次回收都回收整个半区**。



==**该算法的缺点：**==

- **空间浪费**。**可以空间一分为二，相当于每次分配内存只在一个半区里进行。**
- **大量对象存活是，复制过程还是挺降低效率的**。
- **内存担保**。

<img src="imges/WX20200421-162622@2x.png" style="zoom:50%;" />

------

==**备注：**==

​		HotSpot虚拟机`Serial`、`ParNew`等新生代收集器都采用了该算法来回收新生代区域。他将**新生代分为一块较大的Eden空间**和**两块较小的Survivor空间**。**`每次分配内存只使用Eden和其中一块Survivor`**。

​		HotSpot虚拟机**默认Eden和Survivor的大小比例是8∶1**，也即每次**新生代中可用内存空间**为整个新生代容量的**90%**（**Eden的80%加上一个Survivor的10%**）。



-==内存担保机制（看视频再去理解一下这个过程）？？==



------



#### 3.4.3 标记-整理算法

​		老年代对象一般存活比较就，所以不太适用于复制算法，因为复制过程会降低效率。而且也不使用清除算法，因为会引入空间碎片。所以引入一套新的算法思想"**`标记-整理`**"算法。具体过程如下：

​		**标记过程还是和之前的一样，后续步骤不是清除可回收的对象，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存**。

​		

<img src="imges/WX20200421-165153@2x.png" style="zoom:50%;" />

------

==**备注：**==

​		**老年代**如何使用该算法，**每次移动存活对象后，势必要更新所有引用了这些对象的地方（因为内存地址发生了改变）**。**`而且这种对象移动操作必须全程暂停用户应用程序(stop the world)才能进行`**。

==**所以如何衡量性能的优缺点呢？**== 



------

==**灵魂拷问环节**==

**`1.什么时候会出发FullGC？`**







## 3.4 垃圾收集器

**首先迄今为止，所有收集器在枚举GCROOT这一步骤时都是必须暂停用户线程的**。现在可达性分析算法耗时最长的**查找引用链的过程已经可以做到与用户线程一起并发**，**但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行**。**`主要是为了保证在分析过程中，根节点集合的对象引用关系还在是不变化的`**。

这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因。即使是号称停顿时间可控，或者（几乎）不会发生停顿的CMS、G1、ZGC等收集器，枚举根节点时也是必须要停顿的。

	<img src="imges/WX20200422-224151@2x.png" style="zoom:50%;" />



### 3.4.1 Serial收集器

JDK1.3.1之前HotSpot虚拟机新生代收集器的唯一选择。该收集器是一个“**单线程工作**”的收集器。注意，这里的“单线程”指的是**`它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束`**。

<img src="imges/WX20200422-225028@2x.png" style="zoom:50%;" />

他的优点在于：简单高效。Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。



### 3.4.2 ParNew收集器

ParNew收集器实质上是Serial收集器的多线程并行版本。ParNew收集器除了支持多线程并行收集之外，其他与Serial收集器相比并没有太多创新之处。



### 3.4.3 CMS收集器

​		CMS收集器是一种以获**取`最短回收停顿时间为目标`**的收集器。基于**`标记-清除算法`**实现的目前很大一部分的Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上，这类应用通常都会较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。CMS收集器就非常符合这类应用的需求。



CMS收集器是基于标记-清除算法实现的，它的运作过程相对复杂一些，整个过程分为四个步骤：

**1）初始标记**

​		需要**"stop the world"**，初始标记**仅仅只是标记一下GC Roots能直接关联到的对象**，速度很快。

**2）并发标记**

​		

**3）重新标记**



**4）并发清除**



==**CMS的缺点**==

**1）CMS收集器对处理器资源非常敏感。****在并发标记和并发清除阶段，它虽然不会导致用户线程停顿，但却会占用了一部分线程**（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。

**2）无法处理"浮动的垃圾"**。就是在并发清除阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象出现在标记之后，只能等下一次垃圾收集时再清理掉。

**4）CMS是基于"`标记-清除`算法"**。所以存在空间碎片的问题。



### 3.4.4 G1收集器

​		相比CMS，G1的优点有很多，暂且不论**可以指定最大停顿时间、分Region的内存布局、按收益动态确定回收集**这些创新性设计带来的红利。G1也更有发展潜力。与**CMS的“标记-清除”算法**不同，**G1从整体来看是基于“`标记-整理`”算法**实现的收集器，但从**局部（两个Region之间）上看又是基于“`标记-复制`”算法**实现，无论如何，这两种算法都意味着**G1运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存**。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。





# 四.实战篇 - JVM参数【重要】

参考官方文档：[JDK8 VM参数文档](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html)

## 1.标准参数

标准参数：不随着JVM的版本升级而改变的参数。

```java
-version
-help
-server
-cp
```

## 2.非标准参数

```java
-Xms<size>: 设置初始 Java 堆大小
-Xmx<size>: 设置最大 Java 堆大小
-Xss<size>: 设置 Java 线程堆栈大小
-Xmn<size>: 设置年轻代最大空间。Oracle建议将其大小设置为整个堆空间的1/2到1/4之间。
  
// -XX参数：非标准参数，主要用于JVM调优和debug
//boolean类型的 格式：-XX:[+/-]<name>1/
-XX:+UseConcMarkSweepGC: 表示启用CMS类型的垃圾回收器
-XX:+UseG1GC: 表示启用G1类型的垃圾回收器
-XX:+HeapDumpOnOutOfMemoryError: 当出现OOM的时候dump下堆内存快照
//打印每次gc日志，默认这个开关关闭
-XX:+PrintGC
//开发打印每次GC的时间戳
-XX:+PrintGCDateStamps
//开启打印每次gc的详情
-XX:+PrintGCDetails
//gc日志文件的（文件名带上时间戳，当JVM重启时，gcLog将是独一无二的，而且不会存在新的gcLog覆盖调老的gcLog的情况）
-Xloggc:/med/log/gc-%t.log    
  
//2.非boolean类型的
//格式：-XX<name>=<value>: 表示name属性的值是value
-XX:MetaspaceSize=<size>: 
-XX:MaxGCPauseMillis=500: 设置最大暂停时间为500ms
-XX:HeapDumpPath=/tmp: 设置堆内存快照的保存地址

//设置metaspace空间，这个空间的阀值会随着metadat的使用增加和降低，默认大小依赖于具体的平台。
-XX:MetaspaceSize=size
-XX:MaxMetaspaceSize=size

//设置新生(eden+2*s)代和老年代的比率，默认是2（也就是1:2）
-XX:NewRatio=ratio
//设置eden区和survivor区域的比率，默认是8（8:1:1）
-XX:SurvivorRatio=ratio
```

1.打印所有参数

```java
//输出打印所有参数到指定的文件下
java -XX:+PrintFlagsFinal -version > {$PATH}/flags.txt
```

# 五.实战篇-工具的使用

## 1. Java自带的工具



## 2. idea集成VisualVM插件

idea插件仓库地址：[IntelliJ IDEA Ultimate Plugins](https://plugins.jetbrains.com/idea)，搜索`VisualVM Launcher`下载就行了。

**注意：下载插件的时候需要选择对应的idea版本，否则插件可能安装失败。**



插件的配置：

![](imges/WX20200420-163200.png)

## 3. 安装MAT

存在bug，解决办法：[MAT启动报错](https://blog.csdn.net/qq_33589510/article/details/104536803)





# 六.实战篇：OOM的排查问题定位

开源工具：

1.阿里[arthas](https://github.com/alibaba/arthas)



问题：

![](imges/WX20200419-195059.png)

从问题中可以明显的看出：是发生了内存溢出，而且提示也很明显是java堆内存溢出了



**疑问：真的是堆内存溢出了吗？会不会是方法区内存溢出了（因为方法区逻辑上也属于堆）？**

1.首先看一下本地堆内存设计的大小？

![image-20200419195642980](/Users/machen/Library/Application Support/typora-user-images/image-20200419195642980.png)



2.dump下堆内存快照

设置运行时参数：

```shell
-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp
```

参数说明：

- **-XX:+HeapDumpOnOutOfMemoryError**: 当发生OOM是dump错误信息

- **-XX:HeapDumpPath=/tmp**： 设置堆内存文件的路径

  ![](imges/WX20200419-212556.png)

![](imges/WX20200419-212745.png)



MAT介绍指南：[MAT使用指南](https://blog.csdn.net/itomge/article/details/48719527)

MAT插件会给出一份可疑的分析报告，我们只需要结合源代码分析到哪里才是引发问题的真正原因所在：

![](imges/WX20200420-184512.png)



问题复盘：问题如何发生？如何解决？从中能吸取什么教训？



分析目前现状，抛出问题，集中思考。。。

